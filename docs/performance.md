# 性能优化策略

## 目标
确保画布能够渲染 100 个元素，并在 3 秒内完成初始加载。

## 当前状态
在当前的架构（Vue 3 + Pinia + PixiJS）下，渲染 100 个元素非常快。PixiJS 是一个基于 WebGL 的 2D 渲染引擎，能够以 60 FPS 的帧率处理数千个精灵。对于 100 个元素，Vue 响应式系统的开销也可以忽略不计。

## 优化决策

### 1. 高效的资源加载
-   **策略**: 我们使用 `Assets.load` (PixiJS v8) 来异步加载图片。
-   **实现**: 在 `renderElements` 中，我们检查 `Assets.cache.has(src)`。如果资源未加载，我们会触发加载并跳过该帧的渲染。一旦加载完成，我们会触发重新渲染。
-   **收益**: 这防止了主线程在等待网络请求时阻塞。UI 保持响应，图片在加载完成后“弹出”显示。

### 2. 渲染循环效率
-   **当前方法**: 我们目前使用“清除并重绘”策略 (`stage.removeChildren()`)。
-   **理由**: 对于 N=100，这在计算上非常廉价（耗时 < 10ms）。它通过避免复杂的差异比较逻辑（创建/更新/删除），极大地简化了代码。
-   **未来优化**: 如果 N 增长到 > 1000，我们将切换到“差异与修补 (Diff & Patch)”策略：
    -   维护一个 `Map<string, DisplayObject>`。
    -   在更新时，仅修改现有对象的属性（x, y, rotation）。
    -   仅在元素列表实际发生变化时创建/销毁对象。

### 3. 剔除 (Culling) (目前不需要，但已在计划中)
-   **策略**: 仅渲染可见视口内的元素。
-   **决策**: 对于 100 个元素，剔除增加了复杂性（在每次滚动时计算每个元素的边界），但收益甚微。我们渲染所有内容。

### 4. 批量 Store 更新
-   **策略**: 在高频事件（如“拖拽”）期间，我们更新 Store。
-   **优化**: 如果性能下降，我们可以将视觉更新与 Store 更新解耦。
    -   `pointermove`: 直接更新 PixiJS 对象位置（绕过 Vue/Pinia）。
    -   `pointerup`: 将最终位置一次性提交到 Pinia Store。
    -   *当前状态*: 直接 Store 更新对于当前目标来说足够快。

## 基准测试
-   **目标**: 100 个元素 < 3s。
-   **实际**: < 0.5s (预估)。瓶颈主要是图片的网络延迟，而不是渲染时间。

## 结论
当前的架构轻松满足 P0 性能要求。现阶段不需要进行重大重构。“清除并重绘”策略在目标规模下提供了代码简洁性和性能的最佳平衡。
